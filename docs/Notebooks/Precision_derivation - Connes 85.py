
# coding: utf-8

# # Table of Contents
# * [Plot showing the derivation of precision.](#Plot-showing-the-derivation-of-precision.)
# 

# #  Plot showing the derivation of precision.

# [Connes 1985](#cite-Connes1985)   https://doi.org/10.1007/BF00653671

# In[36]:


import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import ArrowStyle
plt.rc('text', usetex=True)


# In[42]:


x = np.arange(0,  1.1, 0.01)

sigma = 0.2
mean = .7
mean2 = mean+ 0.08
ax = plt.subplot(111)
g1 = lambda x: 1 - 0.5/np.sqrt(2*np.pi*sigma**2) * np.exp(-(x-mean)**2 / 2 / sigma**2)
g2 = lambda x: 1 - 0.5/np.sqrt(2*np.pi*sigma**2) * np.exp(-(x-mean2)**2 / 2 / sigma**2) 
#y2 = np.cos(x + np.pi/12)

ax.plot(x, g2(x),"-.",  label=r"$A(\lambda)$")
ax.plot(x, g1(x), label=r"$A_{0}(\lambda)$")


x3 = 0.42
x2 = 0.49
x1 = 0.505  # d lambda
y11 = g1(x1)
y12 = g1(x2)
y21 = g2(x1)
y22 = g2(x2)
#y4 = g2(x2)

# d lambda

plt.annotate(s=r"d$\lambda$", xy=(x2-.02, -0.07), xycoords="data")
ax.vlines(x=x1, ymin=0, ymax=y21, color="orange")
ax.vlines(x=x2, ymin=0, ymax=y21, color="orange")


# Horizontal lines
ax.hlines(y=y11, xmin=0, xmax=x1, color="k", alpha=0.6)
plt.annotate(s=r"$A_{0}$", xy=(0.01, y11-0.07), xycoords="data")
ax.hlines(y=y21, xmin=0, xmax=x1, color="k", alpha=0.6)
plt.annotate(s=r"$A$", xy=(0.01, y21-0.07), xycoords="data")


# Spectral range
s1 = 0.1
As1  = g1(s1)
s2 = 1.0
As2 = g1(s2)
#plt.hlines(y=-0.1, xmin=s1, xmax=s2, color="black", linestyles="dashed", alpha=0.6)
plt.vlines(x=s2, ymin=-0.1, ymax=As2, color="black", linestyles="dashed", alpha=0.6)
plt.vlines(x=s1, ymin=-0.1, ymax=As1, color="black", linestyles="dashed", alpha=0.6)
plt.annotate(s="$\Sigma$", xy=((s2+s1)/2, -0.17), xycoords="data")  # Add end ticks
plt.annotate("", xy=(s1, -0.1), xytext=(s2, -0.1), 
             arrowprops=dict(arrowstyle="<->", color="k",linestyle="dashed",alpha=.6, lw=1.1))

# \delta lambda
plt.annotate(s="$\delta \lambda$", xy=((x1+x3-0.04)/2, 0.85), xycoords="data")
plt.vlines(x=x1, ymin=y21, ymax=0.9, color="grey", linestyles="dashed")
plt.vlines(x=x3, ymin=y21, ymax=0.9, color="grey", linestyles="dashed")
plt.annotate("", xy=(x1, 0.86), xytext=(x1+0.07, 0.86), arrowprops=dict(arrowstyle="->"))
plt.annotate("", xy=(x3, 0.86), xytext=(x3-0.07, 0.86), arrowprops=dict(arrowstyle="->"))

# Hide Ticks
ax.axes.get_xaxis().set_ticks([])
ax.axes.get_yaxis().set_ticks([])

plt.legend(loc="best")
plt.ylabel(r"$A(\lambda)$")
plt.xlabel(r"$\lambda$")

# Hide the right and top spines
ax.spines['right'].set_visible(False)
ax.spines['top'].set_visible(False)

plt.ylim([-0.2,1.1])
plt.show()


# In[ ]:


<!--bibtex

@article{Connes1985,
  title = {Absolute Astronomical Accelerometry},
  volume = {110},
  issn = {1572-946X},
  doi = {10/dk66bp},
  abstract = {Two distinct but fully compatible novel concepts are proposed here for solar/stellar velocity measurements. The first is that of absolute accelerometry proper. This involves two simultaneously, operating servo-control loops First, a variable path-difference Fabry-Perot interferometer is adjusted so that its bandpasses track the fluctuations of either a single spectral line (in the solar case, leading to the solar accelerometer), or of all lines simultaneously (stellar accelerometer). The second loop involves a tunable laser tracking one of the FP bandpasses. The net overall result is that a laser line tracks the stellar/solar ones: the problem of measuring Doppler-shift changes has been transferred from the incoherent to the coherent optics domain. One then measures the beat frequency generated by mixing the tunable laser beam with that of stabilized laser. Only velocity changes are accessible; the devices are true accelerometers, but absolute ones. All instrumental or spectral characteristics drop out; no calibration of any kind is required; hence, one may hope for an unusually low level of systematic errors.},
  number = {2},
  journal = {Astrophysics and Space Science},
  author = {Connes, Pierre},
  month = mar,
  year = {1985},
  pages = {211-255},
  day = {01}
}
-->


# # References
# 
# 
